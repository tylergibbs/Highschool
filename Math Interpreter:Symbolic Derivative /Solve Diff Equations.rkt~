#lang racket
(require racket/syntax)
(require plot)

(struct add (l r)#:transparent)
(struct mul (l r)#:transparent)
(struct exp (l r)#:transparent)
(struct lns (n) #:transparent)
(struct neg (n)#:transparent)
(struct inv (n)#:transparent)
(struct sins (n) #:transparent)
(struct coss (n) #:transparent)


(define-syntax (next stx)
  (syntax-case stx (A R : N)
    [(_ name var vars ... ((x ... N) compstx reff ...))
       #'((λ (x ...) compstx) (reff var)...)
     ]
    [(_ name var vars ... ((x ... R f) compstx reff ...))
       #'((λ (x ...) compstx) (name (f (reff var)) vars ...)...)
     ]
    [(_ name var vars ... ((x ... A) compstx reff ...))
       #'((λ (x ...) compstx) (name (reff var) vars ...)... (reff var)...)
     ]
    [(_ name var vars ... ((x ... : f) compstx reff ...))
       #'((λ (x ...) compstx) (f (name (reff var) vars ...))...)
     ]
    [(_ name var vars ... ((x ...) compstx reff ...))
       #'((λ (x ...) compstx) (name (reff var) vars ...)...)
     ]
    ))

(define-syntax (intrp stx)
  (syntax-case stx ()
    [(_ name (var vars ...) (v ...) (funcn (x ...) -reff ... compstx)...)
     (with-syntax (((func? ...) (map (λ (sym)
                                       (datum->syntax stx 
                                        (string->symbol (string-append 
                                          (symbol->string (syntax->datum sym))
                                          "?"))) )
                                     (syntax->list #'(funcn ...)))
                                                 )
                   (((reff ...)...) (map (λ (sym1 sym2) (map (λ (sym3)
                             (datum->syntax stx 
                                            (string->symbol (begin 
                                                             (string-append 
                                                             (symbol->string (syntax->datum sym1))
                                                             "-"
                                                             (symbol->string (syntax->datum sym3)))
                                                                   ))))
                             (syntax->list sym2)))
                                (syntax->list #'(funcn ...))
                           (syntax->list #'((-reff ...)...))
                           )))
       (with-syntax (
                   ((stmts ...) #'((next name var vars ... ((x ... v ...) compstx reff ...))...))
                   )
     #'(cond
           ((func? var) stmts)...)
         ))]
    ))

(define-syntax (interp stx)
  (syntax-case stx ()
    [(_ name (var vars ...) (funcn (x ...) -reff ... compstx)...)
     #'(interp name (var vars ...)() (funcn (x ...) -reff ... compstx)...)]
    
    [(_ name (var vars ...) (v ...) (funcn (x ...) -reff ... compstx)...)
     #`(define (name var vars ...)
         (intrp name (var vars ...) (v ...) (funcn (x ...) -reff ... compstx)...)
         )]
    ))


(interp numeric? (var)
       (add (x y) l r (and x y))
       (mul (x y) l r (and x y))
       (exp (x y) l r (and x y))
       (lns (x) n (and x))
       (inv (x) n x)
       (neg (x) n x)
       (sins (x) n (and x))
       (coss (x) n (and x))
       (number () #t)
       (symbol () #f)
       )

(interp evaluate (var)
       (add (x y) l r (+ x y))
       (mul (x y) l r (* x y))
       (exp (x y) l r (expt x y))
       (lns (x) n (log x))
       (inv (x) n (/ 1 x))
       (neg (x) n (* -1 x))
       (sins (x) n (sin x))
       (coss (x) n (cos x))
       (number () var)
       (symbol () (error 'error))
       )
(interp subs (var ahsymnum)
       (add (x y) l r (add x y))
       (mul (x y) l r (mul x y))
       (exp (x y) l r (exp x y))
       (lns (x) n (log x 2.72))
       (inv (x) n (inv x))
       (neg (x) n (neg x))
       (sins (x) n (sins x))
       (coss (x) n (coss x))
       (number () var)
       (symbol () (hash-ref ahsymnum var var))
       )
(interp d/dx (var sym neg div)
       (add (x y) l r (add x y))
       (mul (xp yp x y A) l r (add (mul x yp) (mul y xp)))
       (exp (xp yp x y A) l r (if div (mul (exp x (neg y)) (add (neg (mul yp (lns x))) (mul (mul y (inv x)) xp)))
                                  (mul (exp x y) (add (mul yp (lns x)) (mul (mul y (inv x)) xp)))))
       (lns (x) n (div x))
       (inv (x N) n (div (d/dx x neg (not div))))
       (neg (x N) (neg (d/dx x (not neg) div)))
       (sins (xp x A) n (mul (coss x) xp))
       (coss (xp x A) n (mul (mul -1 (sins x))xp ))
       (number () 0)
       (symbol () (if (equal? sym var) 1 0))
       )
(define (numeve exp)
  (if (numeric? exp) (evaluate exp) exp))
(define (same x y alosym)
  (let* ((alon1 (build-list (length alosym) (λ (x) (add1 (random 7)))))
        (alon2 (build-list (length alosym) (λ (x) (add1 (random 7)))))
        (alon3 (build-list (length alosym) (λ (x) (add1 (random 7)))))
        (alon4 (build-list (length alosym) (λ (x) (add1 (random 7)))))
)
  (and (< (abs (- (evaluate (subs x (make-hash (map (λ (xp yp) (cons xp yp)) alosym alon1))))
                            (evaluate (subs y (make-hash (map (λ (xp yp) (cons xp yp)) alosym alon1)))))) .1)
       (< (abs (- (evaluate (subs x (make-hash (map (λ (xp yp) (cons xp yp)) alosym alon2))))
                           (evaluate (subs y (make-hash (map (λ (xp yp) (cons xp yp)) alosym alon2)))))) .1)
       (< (abs (- (evaluate (subs x (make-hash (map (λ (xp yp) (cons xp yp)) alosym alon3))))
                           (evaluate (subs y (make-hash (map (λ (xp yp) (cons xp yp)) alosym alon3)))))) .1)
       (< (abs (- (evaluate (subs x (make-hash (map (λ (xp yp) (cons xp yp)) alosym alon4))))
                           (evaluate (subs y (make-hash (map (λ (xp yp) (cons xp yp)) alosym alon4)))))) .1)
          )))
(interp fix (var alosym neg inv)(: numeve)
       (add (x y ) l r(cond
                        ((same x y alosym) (fix (mul 2 x) alosym #f #f))
                        ((same 0 x alosym) y)
                        ((same 0 y alosym) x)
                        (else (if (numeric? var)
                                  (if (equal? x (* -1 y)) 0 (add x y))
                                  (add x y)))
                        )
            )
       (mul (x y ) l r (cond
                        ((or (same 0 x alosym) (same 0  y alosym)) 0)
                        ((same x 1 alosym) y)
                        ((same y 1 alosym) x)
                        ((same x y alosym) (fix (exp x 2) alosym #f #f))
                        (else (mul x y))))
       (exp (x y ) l r (cond
                        ((same 0 x alosym) 0)
                        ((or (same 1 x alosym) (same 0 y alosym)) 1)
                        ((same 1 y alosym) x)
                        (else (exp x y))))
       (lns (x) n (cond
                        ((same x 1 alosym) 0)
                        (else 
                         (if (numeric? x)
                             (if (< (abs (- x 2.72)) .1) 1 (lns x))
                             (lns x)))
                        ))
       (inv (x) n x)
       (neg (x) n x)
       (sins (x ) n (sins x))
       (coss (x ) n (coss x))
       (number () var)
       (symbol () var)
       )

(interp tostr (var)
       (add (x y) l r (string-append "(" x"+" y")"))
       (mul (x y) l r (string-append "(" x"*" y")"))
       (exp (x y) l r (string-append "(" x "^" y")"))
       (lns(x y) n (string-append "(ln" x y")"))
       (sins (x) n (string-append "(sin" x")"))
       (coss (x) n (string-append "(cos" x")"))
       (number () (number->string var))
       (symbol () (symbol->string var))
       )
(interp get-sym (var)
       (add (x y) l r (append x y))
       (mul (x y) l r (append x y))
       (exp (x y) l r (append x y))
       (lns (x) n x)
       (inv (x) n x)
       (neg (x) n x)
       (sins (x) n x)
       (coss (x) n x)
       (number () '())
       (symbol () (list var))
       )

(define (gradiant sexp)
  (map (λ (x) (d/dx sexp x #f #f)) (get-sym sexp)))
(define (get-func var)
  (local ((define syms (get-sym var))
          (define hs (make-hash (map cons syms (build-list (length syms) (λ (x) x) ))))
          (define (f . x)
            (evaluate (subs var (make-hash (map cons syms x)))))
          )
    f))
(define (plots sexp)
  (plot3d (surface3d (get-func sexp)-10 10 -10 10)))

(d/dx (mul (mul 2 (exp (add 'x -3) 2)) 'x) 'x #F #F)
(tostr(fix (d/dx (mul (mul 2 (exp (add 'x -3) 2)) 'x) 'x #F #F) '(x)#f #f));2(x-3)^2+4x(x-3)
(tostr(fix (d/dx (mul (mul 2 (exp (add 'x -3) 2)) 'x) 'y #F #F)'(x)#f #f))
(tostr(fix (d/dx (exp (mul 2 (exp 'x 3)) 2)'x  #f #f) '(x)#f #f))
(tostr(fix(add (add 2 (exp 2 (add 2 (mul 2 (add 'x 2))))) 3) '(x)#f #f))
(tostr(fix (d/dx (mul 2 (exp (add 'x -3) 2)) 'x #f #f) '(x)#f #f))
(tostr (fix (d/dx (add 'y (mul 'x 'x)) 'x #f #f) '(x)#f #f))
(tostr (fix (d/dx (add 'y (mul 'x 'x)) 'y #f #f) '(x) #f #f))
(map (λ (x) (tostr (fix x '(x y) #f #f))) (gradiant (add (exp 'x 2) (exp 'y 2))))
(plots (add (neg (exp 'y 2)) (neg (exp 'x 2))))
(plots (add (sins 'x) (coss 'y)))